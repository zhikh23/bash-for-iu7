# Учебная практика скриптов BASH для чайников

[Учебная практика BASH-скриптов для чайников](#учебная-практика-bash-скриптов-для-чайников)
- [Учебная практика скриптов BASH для чайников](#учебная-практика-скриптов-bash-для-чайников)
  - [От автора](#от-автора)
  - [Глава I. Да кто этот ваш `.bash`?](#глава-i-да-кто-этот-ваш-bash)
  - [Глава II. Строки — это всё](#глава-ii-строки--это-всё)
    - [2.1. Объявление переменных](#21-объявление-переменных)
    - [2.2. Чтение переменных или почему программистам так много платят](#22-чтение-переменных-или-почему-программистам-так-много-платят)
    - [2.3. Что там, под капотом?](#23-что-там-под-капотом)
    - [2.4. Ввод переменных пользователем](#24-ввод-переменных-пользователем)
    - [2.5. Кавычки? Не, не слышали](#25-кавычки-не-не-слышали)
    - [2.6. Загадочный доллар](#26-загадочный-доллар)
    - [2.7. Позиционные переменные](#27-позиционные-переменные)
    - [2.8. Вопросы существования с точки зрения программиста](#28-вопросы-существования-с-точки-зрения-программиста)
  - [Глава III. Ветвления в bash-е или "А что если..."](#глава-iii-ветвления-в-bash-е-или-а-что-если)
    - [3.1. Синтаксис](#31-синтаксис)
    - [3.2. Чем больше - тем лучше](#32-чем-больше---тем-лучше)
    - [3.2. Социальное дистанционирование](#32-социальное-дистанционирование)
    - [3.3. Вопросы бытия, часть II](#33-вопросы-бытия-часть-ii)
    - [3.4. Advanced-level ветвлений](#34-advanced-level-ветвлений)
      - [Логические операторы и эквивалетность:](#логические-операторы-и-эквивалетность)
      - [`==` и `!=`](#-и-)
    - [3.5. Жизни пробелов тоже важны!](#35-жизни-пробелов-тоже-важны)
    - [3.6. Загадочные минусы](#36-загадочные-минусы)
    - [3.7. =~](#37-)
    - [3.8. Короткая запись условия](#38-короткая-запись-условия)
  - [Глава IV. Что такое регулярные выражения и с чем их есть?](#глава-iv-что-такое-регулярные-выражения-и-с-чем-их-есть)
    - [4.1. Это база!](#41-это-база)
    - [4.2. Снова `[ ]`](#42-снова--)
    - [4.2. Кванторы](#42-кванторы)
    - [4.3. Экранирование](#43-экранирование)
    - [4.4. Повторения](#44-повторения)
    - [4.5. Группы](#45-группы)
    - [4.6. Якоря](#46-якоря)
    - [4.7. Числа!](#47-числа)
  - [Глава V. Магия математики](#глава-v-магия-математики)
    - [5.1. Школьная арифметика](#51-школьная-арифметика)
    - [5.2. Сложение строк?](#52-сложение-строк)
  - [Глава VI. Вот они, слева направо: `for`, `while`, `until`](#глава-vi-вот-они-слева-направо-for-while-until)
  - [Глава VII. М - Массив](#глава-vii-м---массив)
  - [Глава VIII. Маленькие функции для больших задач](#глава-viii-маленькие-функции-для-больших-задач)

<br>
<br>

## От автора

Данная методическое пособие написано для потока 1-го курса ИУ7 2023 года.
Автор не гарантирует истинность изложенного ниже.
Всё, что написано, основано на опыте автора в создании скриптов на языке BASH.

Автор предполагает, что читатель освоил основы языка программирования Python.

Замечания, предложения отправлять:
- В telegram: `@zhikhkirill`
- В VK: `@zhikh.localhost`

## Глава I. Да кто этот ваш `.bash`?

Программисты — люди ленивые, привыкшие все автоматизировать.
Поэтому неудивительно, что появилась такая вещь, как bash-скрипты (далее автор будет называть bash-скрипты просто __bash__).
В bash можно записывать целые сценарии для выполнения рутинной работы. Приведу пример:
```bash 
#!/bin/bash
# test.sh

for file in "./tests/in/*"; do
    cat $file | python3 my_lab.py > ${file/in/out}
done
```
Скрипт автоматически вводит данные в Вашу программу (например, лабораторную по программированию) и записывает результаты в файл.
Таким образом Вы можете протестировать свою программу сразу на нескольких массивах входных данных _одной командой!_
```bash
bash test.sh
```
Неплохо, не правда ли? А ведь это только начало! Возможности BASH-скриптов ограничены лишь Вашим воображением.

И да, `bash` есть на `Linux`-системах. Предмет ПТП подразумевает, что у Вас уже есть данная ОС в любом виде. 

Перейдём к основному материалу.

## Глава II. Строки — это всё

> В bash-e нет типов переменных!

Просто запомните это. Каждый раз, когда Вы используете переменную, помните эти строка.
Чтобы лучше это понять, я задам Вам вопрос: а есть ли типы данных в языке программирования Python (далее — просто Python)? Ведь мы можем сделать так:
```py
a = 5
a = "foo"
```
Как будто у переменной `a` нет определённого типа. Однако это не означает, что в Python нет типов данных. Просто _переменная не имеет строго определённого типа_, т.к. в этом ЯП (язык программирования) _динамическая типизация_.
```py
>>> a = "foo"
>>> type(a)
<class 'str'>
>>> a = 5
>>> type(a)
<class 'int'>
```

А вот с bash-ем все не так:

> В bash все переменные являются строками!

Исходя из этого утверждения будет строиться вся логика работы bash-а.

### 2.1. Объявление переменных

Все просто, например переменная `var` со значением 5:
```bash
var=5
```
Обязательно без пробелов!
```bash
var=5       # CORRECT
var = 5     # INCORRECT
var= foo    # INCORRECT
var =bar    # INCORRECT
```

### 2.2. Чтение переменных или почему программистам так много платят

Просто потому, что они используют символ доллара `$` для чтения переменных:
```bash
a=5
echo $a     # 5
```

Иногда нужно чётко ограничить название переменной, например:
```bash
a=foo
abar="i wanted something else..."
echo $abar      # i wanted something else...
echo ${a}bar    # foobar
```

Как вывести знак доллара, если он означает чтение переменной? Используем экранирование:
```bash
a=5
echo $a
echo \$a
```
Вывод:
```
5
$a
```

### 2.3. Что там, под капотом?

Чтобы понять, как работают переменные под капотом, рассмотрим такой код:
```bash
a="hello"
b="echo $a"
$b
```

> Интепретатор в большинстве случаев не работает с переменными напрямую. Он проходит по строке и заменяет все указания переменных на их соответствующее значение, а _потом исполняет строку как код_.

```bash
   b="echo $a"   # source code
#      |
#  $a -> hello
#      |
#      V
 b="echo hello"  # command
```

```bash
         $b      # source 
#        |
#  $b -> echo hello
#        |
#        V
      echo hello # command
```

Именно поэтому Вы могли часто замечать ошибку `bash: <sth>: not found`. Интепретатор подставляет на место переменной её значение и пытается выполнить как команду.

### 2.4. Ввод переменных пользователем

Если переменные вводятся построчно:
```bash
read a
read b
```

Если через пробел:
```bash
read a b
```

Обратите внимание: никаких `$` не нужно!

Если нужно ввести _не_ через пробел, а, например, через запятую и пробел, можно изменить разделитель:
```bash
IFS=", "
```

Хорошей практикой будет сохранять значение предыдущего разделителя:
```bash
OLD_IFS=$IFS
IFS=", "

read a b

IFS=$OLD_IFS
```

### 2.5. Кавычки? Не, не слышали

Автор часто замечал такую запись:

```bash
# WRONG
a="foo"
```

Или:

```bash
# WRONG
echo "${a}"
```

Однако, кавычки в этих случаях _избыточны_. Нам ничто не мешает сделать так:
```bash
# CORRECT
a=foo
echo $a
```

Потому что вне зависимости от наличия кавычек, переменная все равно будет, и будет она _строковой_.

Но если Вам нужно создать переменную с пробелом внутри, то кавычки обязательны!
```bash
a="foo bar"
```

Аналогично для вывода данных через `echo`. Кавычки в большинстве случаев можно опускать:

```bash
a=foo
b=bar
echo "$a $b"
echo $a $b
```
Вывод будет:
```
foo bar
foo bar
```

Вот случай, когда без кавычек никак:
```bash
echo "$a "
```

А как вывести строку с кавычками? Применяем экранирование:
```bash
a=foo
b=bar
echo \"$a $b\"
```
Тогда вывод будет:
```
"foo bar"
```

Не нужен перевод на новую строку? Делаем так:
```bash
echo -n "some"
echo " text"
```
Вывод:
```
some text
```

### 2.6. Загадочный доллар

В bash-е есть уникальные переменные. Одна из них - это `$?`.
Её значение равно _коду возврату последней выполненной команды_. Например:
```bash
some_program
echo $?
```

> Код возврата равен 0, если программа завершилась успешно.

Поэтому команда `true` (да, есть такая команда) всегда возвращает `0`, а `false` - `1`.
```bash
true
echo $?     # 0
false
echo $?     # 1
```

Зачем это надо? Вернёмся к `$?` в будущем.

### 2.7. Позиционные переменные

Ещё один тип особых переменных.
Увидим их в действии. Запустим такой код:

```bash
# test.sh
echo \$0=$0 
echo \$1=$1
```
Запускаем вот так:
```
your-directory@username$ bash test.sh hello
```
Получаем ответ:
```
$0=your-directory/test.sh
$1=hello
```

Как Вы заметили, `$n`, где n — неотрицательное число, это ничто иное, как аргументы при запуске скрипта. Причём первый (т.е. нулевой аргумент) _это всегда абсолютный путь до иcполняемого файла_.

Т.е. если ваша программа лежит тут:
```
/home/iushnik-s-semerki/scripts/my_script.sh
```
То переменная `$0` соответственно будет равна этому значению.

А для остальных:
```bash
# test.sh
echo \$1=$1
echo \$2=$2
echo \$3=$3
```
```bash
bash test.sh foo bar "foo bar"
```
```bash
$1=foo
$2=bar
$3=foo bar
```

Можно читать аргументы запуска скрипта не по отдельности, а сразу:
```bash
# test.sh a b c
echo $*     # a b c
echo $@     # a b c
```

Отличие `$*` от `$@` будет рассмотренно в главе 6.

### 2.8. Вопросы существования с точки зрения программиста

А что, если мы попытаемся обратиться к несуществующей переменной?
Попробуем:
```bash
a=5
echo $a
echo $b
```
И мы получим...
```
5

```
... просто пустую строку на месте переменной `b`! Никаких вам `NameError: name 'b' is not exists`! 

> В bash несуществующая переменная является пустой строкой.

Поэтому код ниже абсолютно рабочий:
```bash
echo $a             # Empty output
b=$a                # Empty var 'b'
c="my answer: $a"   # my answer: 
```

Ещё можно удалить переменную командой `unset`
```bash
a=5
echo $a     # 5
unset a
echo $a     # nothing
```

А как определять, существует ли переменная? Об этом пойдёт речь в следующей главе.

## Глава III. Ветвления в bash-е или "А что если..."

### 3.1. Синтаксис

Красиво и понятно. Что ещё можно сказать?
```bash
if [ $a ]
then
    echo Hello!
fi
```

Несколько логических строчек кода можно расположить на одной физической, применяя разделитель `;`:
```bash
if [ $a ]; then
    echo Hello!
fi
```

Немножко вариативности:

```bash
if [ $a ]; then
    echo $a
else
    echo ERROR
fi
```

Или так:
```bash
if [ $a ]; then
    echo $a
else if [ $b ]; then
    echo $b
fi
fi
```

Обратите внимание: каждый раз, открывая условие `if`, необходимо его закрыть `fi`. Дважды использовали `if` — дважды закрыли `fi`.

Однако можно быть проще:
```bash
if [ $a ]; then
    echo $a
elif [ $b ]; then
    echo $b
fi
```

### 3.2. Чем больше - тем лучше

"Подождите, но я видел такие же условия, но с `[[ ]]`. А в чём отличие?"

Дело в том, что до `bash`-а был `sh`. Но bash в отличие от последнего имеет множество нововведений. Для обратной совместимости все возможности shell-а были сохранены, а новые "фишки" появились в новых скобках - тех самых `[[ ]]`.

Какой вывод можно сделать? Т.к. в курсе ПТП мы рассматриваем исключительно bash, и не требуется никакой обратной совместимости со старым интепретатором, смело используем `[[ ]]`.

> Если сомневаетесь, то между `[ ]` и `[[ ]]` выбирайте двойные скобки!

Далее автор будет использовать оба варианта записи.

### 3.2. Социальное дистанционирование

> `[ ]` и `[[ ]]` _требуют пробелов рядом с собой_!

```bash
if [$a]; then echo foo; fi      # INCORRECT
if [ $a ]; then echo bar; fi    # CORRECT

if [[$a]]; then echo foo; fi    # INCORRECT
if [[ $a ]]; then echo foo; fi  # CORRECT
```

### 3.3. Вопросы бытия, часть II

А теперь ответим на вопрос, заданный в предыдущей главе. Проверить переменную на существование очень просто:
```bash
if [ $a ]; then
    echo "\$a exists; \$a=${a}"
else
    echo "\$a does not exists"
fi
```
Просто и надёжно. Пользуйтесь на здоровье!

### 3.4. Advanced-level ветвлений

#### Логические операторы и эквивалетность:

В порядке приоритета:
1. `не`  = `!`
2. `и`   = `&&`
3. `или` = `||`

Пример использования:
```bash
if [ ! $a ] && ! [ $b ] || [ $c ]; then
    ...
fi
```

`!` можно записать как внутри `[ ]`, так и снаружи, чего не скажешь про `&&` и `||`.

Можно использовать `( )` для изменения приоритета:
```bash
if ! ([ $a ] && [ $b ]); then 
    echo ERROR
fi
```

#### `==` и `!=`

Несложно догадаться, для чего нужны эти операторы. Записывать внутри скобок:
```bash
if [[ $a == $b ]]; then
    echo \'a\' is \'b\'
fi
```

```bash
if [[ $a != $b ]]; then
    echo \'a\' is not \'b\'
fi
```

Тот случай, когда нужно использовать `[[  ]]`. Просто запомните.

### 3.5. Жизни пробелов тоже важны!

Пробелы очень важны! Очень легко потерять пробел и сломать скрипт:

```bash
# INCORRECT
![ $a ]               
!([ $a ] && [ $b ])
[[$a == $b]]
[[ $a!=$b ]]
```

```bash
# CORRECT
! [ $a ]               
! ([ $a ] && [ $b ])
[[ $a == $b ]]
[[ $a != $b ]]
```

### 3.6. Загадочные минусы

Есть более архаичная запись всего того, что было перечислено:
```bash
[ $a -a $b ]    # AND
[ $a -o $b ]    # OR
[ $a -eq $b ]   # ==
```

Но тут придётся использовать экранирование `()`:
```bash
[ ! \( $a -a $b \) ]    # equivalent to "! ([ $a ] && [ $b ])"
```

Забегая вперёд: если `$a` и `$b` являются числами, можно использовать такие операторы:
```bash
[ $a -lt $b ]   # <
[ $a -ge $b ]   # >=
```

"Зачем оно нужно?". Возвращаясь к теме обратной совместимости, такая запись использовалась в shell-е, а в bash перешла по наследству. 

На этом автор оставит минусы в покое и далее использоваться они не будут.

### 3.7. =~

Оператор `=~` определяет соответствие строки регулярному выражению.

Синтаксис:
```bash
if [[ $a =~ ^[+-]?[0-9]+$ ]]; then
    echo \'\$a\' is number!
fi
```

Обратите внимание: __никаких кавычек!__

```bash
a=123
if [[ $a =~ "^[0-9]+$" ]]; then
    echo foo
fi
if [[ $a =~ ^[0-9]+$ ]]; then
    echo bar
fi
```
Вывод будет, как вы можете проверить:
```
bar
```

О регулярных выражения пойдет речь в 4-ой главе.

### 3.8. Короткая запись условия

Для тех, кто честно дочитал до этого момента (да ведь?), будет показан интересный трюк.

Вместо того, чтобы писать
```bash
if [ ! $a ]; then
    echo ERROR
fi
```
Можно сделать так:
```bash
[ ! $a ] && echo ERROR
```

Или даже так:
```bash
[ $a ] && echo $a || echo ERROR
```

Что будет эквивалентно:
```bash
if [ $a ]; then
    echo $a
else
    echo ERROR
fi
```

Удобно, не правда ли? Но

> Однако лучше избегать такой записи условия.

Злоупотребление такой формой приводит к нечитабельности кода. 


## Глава IV. Что такое регулярные выражения и с чем их есть?

> [https://regex101.com](https://regex101.com/) — регулярные выражения лучше всего писать и тестировать именно здесь. И все примеры лучше проверять здесь

Регулярное выражение, простыми словами — некоторый шаблон, по которому можно определить соответствие строк. Это не строгое сравнение, как в случае с `==`, а "умное". По регулярным выражениям есть целый предмет — Теория Формальных Языков (ТФЯ), кошмар для ИУ9.

Регулярные выражения — очень полезный инструмент, с базовыми основами которого попробуем разобраться в этой главе.

_Единственное, что не могут регулярные выражения — так это [распарсить HTML](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags)_

### 4.1. Это база!

Регулярные выражения могут не использовать специальных символов:
```re
text
```
Для строки:
```
some text
```
данному регулярному выражению будет соответствовать подстрока:
```
text
```
(проверьте на сайте выше, как это выглядит)

Пример:
```bash
if [[ "some text" =~ text ]]; then
    echo yes
else
    echo no
fi
```

`"some text"` - это строка, которую проверяем на соответствие регулярному выражению (на этом месте может быть переменная), и `text` - как ни странно, __само регулярное выражение__, просто записанное без спец. символов.

Т.к. в строке `some text` есть подстрока `text`, результатом работы скрипта будет ответ `yes`.

### 4.2. Снова `[ ]`

`[ ]` - обозначают любой символ внутри. Например:

```re
[ab]c
```
Будут соответствовать строки:
```
ac
bc
```

Чтобы не писать весь алфавит, можно использовать диапазоны:
- `[A-Z]` - заглавные латинские буквы
- `[a-z]` - строчные латинские буквы
- `[A-z]` - латинские буквы (именно в таком порядке!)
- `[0-9]` - цифры
- `[0-f]` - так тоже можно, это будут шестнадцатеричные цифры в нижнем регистре

Например:
```re
[0-2][0-9]
```
Будут соответствовать строки:
```
00
18
29
```
и т.п.

Чтобы не перебирать все возможные символы, "любой символ" можно задать `.`:
```
..
```
Будут соответствовать строки:
```
ab
5$
```

### 4.2. Кванторы

Если простым языком, кванторы определяют количество предыдущей строки/символа в подстроке.
- `?` - от 0 до 1
```re
[0]?[1-9]
```
Будут соответствовать строки:
```
2
01
```

- `*` - больше или равно 0
```re
[0-9]*
```
Будут соответствовать строки:
```

0
35434646
```

- `+` - больше 0
```re
[0-9]+
```
Будут соответствовать строки:
```
1
1235
```

### 4.3. Экранирование

Чтобы использовать специальный символ как сам символ, используется __экранирование__ при помощи символа `\`.
Например, если нам нужно регулярное выражение на проверку расширения файла:
```re
.*\.txt
```
Первая точка будет обозначать __любой символ__, а вторая, экранированная, обозначает саму себя, т.е. точку.


### 4.4. Повторения

Если нужно конкретное количество повторений подстроки, используются такие скобки — `{}`:
```re
[1-9][0-9]{3}
```
Будут соответствовать строки:
```
1830
2023
```

Или можно записать так:
```re
[1-9][0-9]{1-3}
```
Будут соответствовать строки:
```
10
128
1830
```

### 4.5. Группы

Если кванторы нужно применить не к одному символу, можно оборачивать нужную подстроку в _группу_ `( )`:
```re
(ab)*
```
Будут соответствовать строки:
```

ab
ababab
```

### 4.6. Якоря

Якоря обозначают начало и конец строки:
- `^` - начало строки
- `$` - конец строки

При помощи якорей можно "отбросить" соответствие на подстроки. Например:
```bash
[[ "file.txt.a" =~ .*\.txt ]]    # True
[[ "file.txt.a" =~ .*\.txt$ ]]   # False
[[ "file.txt" =~ .*\.txt$ ]]     # True
```

### 4.7. Числа!

Итак, наконец мы получили достаточно знаний для написания регулярного выражения для целого числа:
```re
^[-+]?[0-9]+$
```
Разберем каждый символ:
- `^` - начало строки, т.е. мы отбрасываем "ab566" значения
- `$` - конец строки, т.е. мы отбрасываем "1223ab" значения
- `[-+]` - любой символ, + или -
- `[-+]?` - обозначет, что "+" или "-" необязательны, но они могут быть в строке, обозначающей число
- `[0-9]` - любая цифра
- `[0-9]+` - цифра должна быть хотя бы одна

Можно попробовать сделать регулярное выражение для дробного числа:
```re
^[+-]?[0-9]+(\.[0-9]+)?$
```
Подробнее:
- `[+-]?[0-9]+` - проверка на подстроку-число из предыдущего примера. Обратите внимание, что якоря "переехали", т.к. начало и конец строки теперь в других местах.
- `\.` - точка как символ точки
- `\.[0-9]+` - дробная часть числа
- `(\.[0-9]+)?` - дробная часть числа необязательная

Автор настоятельно рекомендует самостоятельно попробовать написать регулярные выражения для даты, для закрепления материала.

## Глава V. Магия математики

Только теперь можно приступить к математическим операциям.
Числа желательно проверять регулярным выражением, т.к. все в bash-у является строкой и нет отдельного типа данных для чисел.

```bash
read a b
re_num=^[-+]?[0-9]+$
if ! ([[ $a =~ re_num ]] && [[ $b =~ re_num ]]); then
    echo ERROR
else
    ...
fi
```

### 5.1. Школьная арифметика

> Bash не поддерживает арифметические операции с дробными числами.

Совсем. И незачем. Bash-у не нужно что-то считать, с этой задачей справится любой классический полноценный язык программирования.
Поэтому берём только целые числа.

Для произведения математических операций используются скобки `$(( ))`:

```bash
a=5
b=6
echo $((a + b))
```

Как можно заметить, `$` внутри математических скобок писать _необязательно_.

Какие операции поддерживаются?
- `+`, `-`, `*`, `/` (целочисленное), `%`, `**`
- `+=`, `-=`, `*=` и т.п.
- `++` и `--`

### 5.2. Сложение строк?

Сложить строки в bash как в Python-e нельзя. Любые попытки подставить _не число_ в `$(( ))` окончится провалом. И просто `+` тоже записать нельзя. "А как тогда сложить строки?". Очень просто. Конкатенация строк (а именно так это называется) выглядит так:
```bash
a=ab
b=5
c=${a}${b}  # ab5
```

## Глава VI. Вот они, слева направо: `for`, `while`, `until`

## Глава VII. М - Массив

## Глава VIII. Маленькие функции для больших задач
